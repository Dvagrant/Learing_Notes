快照读不会产生幻读，只有当前读才会由于读取到没有锁住的行。

---
## 幻读造成的一致性问题
### 只对记录加锁
``` sql
CREATE TABLE `t` ( 
	`id` int(11) NOT NULL, 
	`c` int(11) DEFAULT NULL, 
	`d` int(11) DEFAULT NULL, 
	PRIMARY KEY (`id`), 
	KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

![[幻读-只锁记录造成的一致性问题.png]]

#### 以上流程执行的结果（没有加 GAP 锁
1. 经过 T1 时刻，id=5 这一行变成 (5,5,100)，结果最终是在 T6 时刻正式提交
2. 经过 T2 时刻，id=0 这一行变成 (0,5,5)
3. 经过 T4 时刻，表里面多了一行 (1,5,5)

#### 以上语句的binlog
``` sql 
update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/

insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/
```
这个语句序列，不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。

***如果没有锁住语义上的行，由于事务提交的时序原因，会出现后 insert 的语句先一步在 binlog 里出现，之前的语句提交后，会在 binlog 的后面修改了刚刚 Insert 的数据，造成数据不一致。***

---
### 对扫描到的行加锁

![[幻读-只对扫描到的行加锁.png]]

#### 以上语句的binlog
``` sql
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/

update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
```
即使对所扫描的行全部加锁，由于之后的语句会提交不存在的记录，依旧会由于提交时序问题造成数据不一致。

***即使锁住了所有扫描到的行，由于谓词条件中的数据可能不存在，之后开始但先提交的事务依旧会放入语义上存在的行，只能对有可能出现的，满足谓词条件的记录也做锁定（禁止插入），才能改变数据不一致问题***

---
## 解决幻读引入的锁
数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。跟间隙锁存在冲突关系的，是**往这个间隙中插入一个记录**这个操作。间隙锁之间都不存在冲突关系。

间隙锁和行锁合称`next-key lock`，每个`next-key lock`是前开后闭区间。

由于间隙锁互不冲突，出现多线程进行存在则更新，不存在则插入时，由于不存在而上的 GAP 锁极其容易引起死锁。间隙锁的引入，可能会导致同样的语句锁住更大的范围，影响了并发度。

间隙锁是为了解决RR级别下出现的幻读而引入的，可以设置隔离级别为RC，便不会有间隙锁（此时为了解决binlog的一致性问题，binlog需要设置为 row 格式）。