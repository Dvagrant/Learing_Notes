## count(\*)的实现
- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(\*) 的时候会直接返回这个数，效率很高
- 而 InnoDB 引擎就麻烦了，它执行 count(\*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。

由于 MVCC 的关系，同一个时刻，不同事务要返回的 count(\*)数量也是不同的。`count(主键ID)`已经做了优化，普通索引树比主键索引树小很多，优化器会找到最小的一棵树来遍历。**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**

`show table status`可以显示`table_rows`字段，但此数量是由索引采样估算出来的，并不准确。

---
- MyISAM 表虽然 count(\*) 很快，但是不支持事务
- show table status 命令虽然返回很快，但是不准确
- InnoDB 表直接 count(\*) 会遍历全表，虽然结果准确，但会导致性能问题

所以我们可以自己计数。
#### 使用Redis缓存保存记录
问题1：Redis重启的过程中，有可能丢失最新的+1操作。可通过重启后在 MYSQL 中单独执行一次 count(\*)解决。

问题2：由于是两个服务，会造成逻辑不一致。（分布式一致性问题

情形1。此时会话B可以查到最新的记录，但是计数器并没有+1
![[分布式一致性-1.png]]

情形2.此时计数器+1，但查不到最近的操作记录。
![[分布式一致性-2.png]]


---
## 数据库中保存计数
正是因为事务的一致性问题，导致每次 count(\*) 都需要去重新遍历。则可以通过事务，来保证一致性。

情形3。不使用分布式系统，单点操作的一致性，通过事务保证。
![[单点系统的一致性.png]]
会话A中的操作没有提交，对会话B不可见。会话B查询到的数据计数器没有+1，操作记录也没有最新的。

---
## 不同的count
count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。

所以，count(\*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，字段不为 NULL 的总个数。
>分析性能问题的主要原则
>1. server 层要什么就给什么
>2. InnoDB 只给必要的值
>3. 现在的优化器只优化了 count(\*) 的语义为“取行数”，其他“显而易见”的优化并没有做

**对于count(主键ID)**，InnoDB会遍历整张表（最小索引树），把每一行的 ID 取出后返回给 server ，server 拿到结果后判断 NULL 

**对于count(1)**，引擎遍历表，但不取值，server 对于返回的每一行放一个数字 “1” 进去，判断 NULL ，按行累加。

对比以上两个操作，显然 count(1) 更快，因为不涉及从引擎中拿出数据后解析，以及拷贝数值到 server 中

**对于count(字段)**，
1. 字段定义为 NOT NULL ，则一行行的取字段，按行累加。
2. 字段允许 null ，取出后判断不为 null 则累加。

**对于count(\*)**，由于肯定不为 NULL ，优化为不取值，按行累加。

所以结论是：按照效率排序的话，count(字段)< count(主键ID)< count(1) 约等于 count(\*).