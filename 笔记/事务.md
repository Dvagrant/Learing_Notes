## TRANSACTION
事务，一系列操作打包成为的一个操作序列。

事务有ACID（`Atomicity`、`Consistency`、`Isolation`、`Durability`，即原子性、一致性、隔离性、持久性）的特性。

当数据库中有多个事务在执行时，就可能出现脏读`dirty read`、不可重复读`non-repeatable read`、幻读`phantom read`的问题，为了解决这些问题，就有了“隔离级别”的概念。

SQL 标准的事务隔离级别包括：读未提交`read uncommitted`、读提交`read committed`、可重复读`repeatable read`和串行化`serializable`。
- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

>为了实现不同的隔离级别，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

---

### 可重复读的数据库实现

MYSQL中每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
***即事务中会记录两条日志，一条[[日志系统#REDO LOG|undo]]用来保证原子性（可能要回滚），一条[[日志系统#REDO LOG|redo]]用来保证持久性（宕机了也可以`crash-recovery`）。另外事务提交时还要记录[[日志系统#BINLOG|binlog]]***

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。
![[回滚日志.png]]
当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的`read-view`。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的**多版本并发控制**（`MVCC`）。对于`read-view A`，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。
同时会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟`read-viewA、B、C`对应的事务是不会冲突的。

回滚日志总不能一直保留，当系统里没有比这个回滚日志更早的`read-view`的时候（没有比回滚日志更早的读视图，就一定不会有事务需要回滚到此版本，因为读视图只能看到比自己事务ID更大的版本数据），系统会将此事务的回滚日志删除。

***为什么不要使用长事务***
长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在`ibdata`文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小（***一个文件在文件系统中的存放分为两个部分：数据部分和指针部分，指针位于文件系统的meta-data中，数据被删除后，这个指针就从meta-data中清除了，而数据部分存储在磁盘中，数据对应的指针从meta-data中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，但不会直接删除文件***）。除了对回滚段的影响，长事务还占用[[锁]]资源，也可能拖垮整个库。可以在`information\_schema`库的`innodb\_trx`这个表中查询长事务。

---
### 事务的启动
事务有以下的启动方式：
- 显式启动事务语句，`begin`或`start transaction`。配套的提交语句是`commit`，回滚语句是`rollback`。
- `set autocommit=0`，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个`select`语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行`commit`或`rollback`语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个`set autocommit=0`的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此建议总是使用`set autocommit=1`, 通过显式语句的方式来启动事务。
*在 `autocommit=1`的情况下，用 `begin`显式启动的事务，如果执行`commit`则提交事务。如果执行`commit work and chain`，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。*

---



---
## 事务隔离级别实现的方法
只有读提交和可重复读需要使用MVCC，串行读使用加锁来保证事务顺序。

`begin/start transaction`命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。
如果你想要马上启动一个事务，可以使用`start transaction with consistent snapshot`这个命令。
- 第一种启动方式，一致性视图是在执行第一个快照读语句时创建的
- 第二种启动方式，一致性视图是在执行`start transaction with consistent snapshot`时创建的。

事务启动时（事务ID严格自增），通过拿到可见视图数组，构成一致性视图。
需要回滚时，通过`UNDO LOG`与一致性视图配合，找到可见的版本。

![[数据版本可见性(一致性可见视图).png]]
上图中，记录了一个视图的可见数据版本，即一致性视图。

InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。
数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。

**绿色部分一定是已经提交的事务（活跃事务的最小ID是低水位），红色部分一定是在此事务开始后新增的事务（高水位是当先事务ID），黄色部分是当前正在进行的事务（未提交）**

对于当前事务的启动瞬间来说，一个数据版本的`row trx_id`，有以下几种可能：
1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
	- 若`row trx_id`在数组中，表示这个版本是由还没提交的事务生成的，不可见；
	- 若`row trx_id`不在数组中，表示这个版本是已经提交了的事务生成的，可见。

> 在水位中，也可能有间隙，例如水位是100-200，但事务ID为150的事务已经提交了，是不会在一致性视图中的，因为一致性视图数组中，记录的只是活跃事务的ID。所以对于单个事务，在它视图数组中一定是还未提交的事务（最小活跃ID之前的事务肯定已经提交，在最小活跃ID与当前事务ID之前提交的ID不在数组中）
> 
>这样以来，数据的`trx_id`在视图数组中，则版本一定是未提交的，不可见。（`trx_id`是高水位的话，则是属于当前事务自己的更新，则可见）

---
## 当前读与快照读
在RR隔离级别下，虽然读时要用一致性视图，但更新时一定要用最新版本，如果用旧版本更新，则会覆盖掉其他事务的更新。
更新时总会使用当前读`select for update/lock in share mode`来获取数据（分别加读锁与写锁）。

---
![[2PL阻塞.png]]
若当前事务A需要更新的数据，被事务B更新了（但未提交），则在2PL的影响下，事务A必须阻塞等待事务B提交或回滚。

---
![[使用当前读更新数据.png]]
若当前事务A需要更新的数据，事务B更新了（已经提交），则对于事务A来说B版本的数据是历史数据。事务A更新时由于使用当前读，可能会破坏语义上的一致性（consistency）

**事务B加了1并提交，事务A加1后查询，为了保证不丢失事务B更新，事务A会在事务B的版本上更新，之后使用当前读会读到+2的结果，破坏了一致性**

---
## 事务的可重复读的能力是怎么实现的？
可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

InnoDB 的行数据有多个版本，每个数据版本有自己的 `row trx_id`，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据`row trx_id`和一致性视图确定数据版本的可见性。
- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据