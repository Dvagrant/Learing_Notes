## TRANSACTION
事务，一系列操作打包成为的一个操作序列。

事务有ACID（`Atomicity`、`Consistency`、`Isolation`、`Durability`，即原子性、一致性、隔离性、持久性）的特性。

当数据库中有多个事务在执行时，就可能出现脏读`dirty read`、不可重复读`non-repeatable read`、幻读`phantom read`的问题，为了解决这些问题，就有了“隔离级别”的概念。

SQL 标准的事务隔离级别包括：读未提交`read uncommitted`、读提交`read committed`、可重复读`repeatable read`和串行化`serializable`。
- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

>为了实现不同的隔离级别，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

---

### 可重复读的数据库实现

MYSQL中每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
***即事务中会记录两条日志，一条[[日志系统#REDO LOG|undo]]用来保证原子性（可能要回滚），一条[[日志系统#REDO LOG|redo]]用来保证持久性（宕机了也可以`crash-recovery`）。另外事务提交时还要记录[[日志系统#BINLOG|binlog]]***

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。
![[回滚日志.png]]
当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的`read-view`。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的**多版本并发控制**（`MVCC`）。对于`read-view A`，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。
同时会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟`read-viewA、B、C`对应的事务是不会冲突的。

回滚日志总不能一直保留，当系统里没有比这个回滚日志更早的`read-view`的时候（没有比回滚日志更早的读视图，就一定不会有事务需要回滚到此版本，因为读视图只能看到比自己事务ID更大的版本数据），系统会将此事务的回滚日志删除。

***为什么不要使用长事务***
长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在`ibdata`文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小（***一个文件在文件系统中的存放分为两个部分：数据部分和指针部分，指针位于文件系统的meta-data中，数据被删除后，这个指针就从meta-data中清除了，而数据部分存储在磁盘中，数据对应的指针从meta-data中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，但不会直接删除文件***）。除了对回滚段的影响，长事务还占用[[锁]]资源，也可能拖垮整个库。可以在`information\_schema`库的`innodb\_trx`这个表中查询长事务。

---
### 事务的启动
事务有以下的启动方式：
- 显式启动事务语句，`begin`或`start transaction`。配套的提交语句是`commit`，回滚语句是`rollback`。
- `set autocommit=0`，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个`select`语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行`commit`或`rollback`语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个`set autocommit=0`的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此建议总是使用`set autocommit=1`, 通过显式语句的方式来启动事务。
*在 `autocommit=1`的情况下，用 `begin`显式启动的事务，如果执行`commit`则提交事务。如果执行`commit work and chain`，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。*