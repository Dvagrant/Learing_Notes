## UNDO LOG
**[[事务]]**有ACID的特性，为了满足原子性，必须有回滚操作，为了避免内存运算过程中掉电丢失信息（事务未提交时宕机必须要回滚），回滚信息必须先被持久化到磁盘，于是有了`UNDO LOG`
`undo log`是回退日志，提供 **回滚** 操作。
只用`undo log`实现原子性和持久性的缺陷：
- 事务提交前需要将`Undo Log`写磁盘（提供可回滚功能，保证原子性），这会造成多次磁盘 IO（不考虑各种优化例如 SQL 解析优化等），这些 IO 算是顺序 IO
- 事务提交后需要将数据立即更新到数据库中，这又会造成至少一次磁盘 IO，这是一次随机 IO

在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在`ibdata`文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小（标记回收后可以重复使用，但文件大小不变）。
 5.7版本支持单独配置`undo log`的路径和表空间文件。

---
## REDO LOG 
为了保证持久性，**[[事务]]**提交后需要落盘永久存储，但每次提交都刷脏（落盘）会带来极大的IO开销。

如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即`Redo Log`.

在事务提交前，只要将`Redo Log`持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是`Redo Log`已经持久化。系统可以根据`Redo Log`的内容，将所有数据恢复到最新的状态。

`redo log` 是INNODB引擎特有的日志系统，提供 **前滚** 操作，为了崩溃恢复`crash-safe`。（另有 **[[INNODB特性#DOUBLE WRITE技术|double write]]** 保证 `redo log` 的崩溃恢复）

`redo log` 是固定大小的（4个1GB大小的文件），记录物理日志，即页的改动。例如偏移量为***0faadde12***的位置上设为***a***。页本身遭受破坏时无法恢复，所以要用**[[INNODB特性#DOUBLE WRITE技术|double write]]**保证`REDO LOG`的完整性。
4个文件循环写，使用`checkpoint`推进。
`innodb_flush_log_at_trx_commit`这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。
> InnoDB 有 `buffer pool`（简称bp）。bp 是 **物理页** 的缓存，对 InnoDB 的任何修改操作都会首先在 bp 的 page 上进行，然后这样的页面将被标记为 dirty 并被放到专门的flush list 上，后续将由专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机 IO，阶段性的刷脏可以将多次对页面的修改 merge 成一次IO 操作，同时异步写入也降低了访问的时延。
> 
> 然而，如果在 dirty page 还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb 将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是 redo log file。这样的技术推迟了 bp 页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销（顺序 IO，比随机 IO 快很多），以及数据库启动时恢复操作所需的时间。

![[三种Page和List.png]]

---
## redo/undo log
将二者结合，提高效率。
> 要从两个角度来优化，一个就是尽可能减少写入硬盘（即多个事务合并成一次落盘），
> 另一个就是尽量顺序写入（HDD 的随机写入性能远差于顺序写入）。

`Undo`记录某 **数据** 被修改 **前** 的值，可以用来在事务失败时进行 rollback；  
`Redo`记录某 **数据块** 被修改 **后** 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。  
即，

- `Redo Log`保证事务的持久性
- `Undo Log`保证事务的原子性（在 InnoDB 引擎中，还用 Undo Log 来实现 MVCC）

比如某一时刻数据库 DOWN 机了，有两个事务，一个事务已经提交，另一个事务正在处理。数据库重启的时候就要根据日志进行前滚及回滚，把已提交事务的更改写到数据文件，未提交事务的更改恢复到事务开始前的状态。即，当数据`crash-recovery`时，通过`redo log`将所有已经在存储引擎内部提交的事务应用`redo log`恢复，所有已经`prepared`但是没有`commit`的`transactions`将会应用`undo log`做`roll back`

#### 为什么只用 redo-log 或者只用 undo-log 不可以
-   假设只有`undo-log`：那么就必须保证提交前刷脏完成，否则宕机时有些修改就在内存中丢失了（**不刷脏数据就没有落盘，只在内存中**），破坏了持久性。（这样带来了一个问题，那就是前面提到的性能差）
-   假设只有`redo-log`：那么就不能随心所欲地在事务提交前刷脏（因为如果刷脏进行了一半宕机，没有日志就会丢失在内存中尚未刷脏完成的数据，**无法回滚**），即无法支持大事务。（假如、某张表有 100 亿的 8 字节整数数据，就算不考虑其他东西带来的损耗，光 update 整张表至少要消耗 80G 的内存。如前所述，有了 undo-log，就可以随便刷脏。）

---
## BINLOG
`binlog`是MYSQL服务层自带的归档日志。
`sync_binlog`这个参数设置成 1 的时候，表示每次事务的`binlog`都持久化到磁盘。`redo/undo`在 **事务执行过程中** 会不断的写入，而`binlog`是在 **事务最终提交前** 写入的。
它有三种模式：
- `statement`：基于SQL语句的模式，某些语句中含有一些函数，例如`UUID`,`NOW`等在复制过程可能导致数据不一致甚至出错。
- `row`：基于行的模式，记录的是行的变化，更新前，更新后都记录，很安全。但是`binlog`的磁盘占用会比其他两种模式大很多，在一些大表中清除大量数据时在`binlog`中会生成很多条语句，可能导致从库延迟变大。
- `mixed`：混合模式，根据语句来选用是`statement`还是`row`模式



---
## UPDATE流程
``` sql
update T set c=c+1 where ID=2
```
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 `redo log` 里面，此时 `redo log` 处于 ***prepare*** 状态。然后告知执行器执行完成了，随时可以提交事务。(**[[INNODB特性#WAL技术（write-ahead logging）|WAL技术]]**)
4. 执行器生成这个操作的`binlog`，并把`binlog`写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的`redo log`改成提交***commit***状态，更新完成。

![[UPDATE流程图.png]]update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

---
## 两阶段提交(2PC)
两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案。
`redo log`和`binlog`都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。